#!/usr/bin/python3
#x3.out.filter=^(?P<prefix>[a-z0-9._-]+\.httpprobe)\.(result|responsetime|result\.comment)$
#x3.prefix=be.fedict.eid
#x3.timeout=10
#x3.interval=1.0

#   ExtreMon Project
#   Copyright (C) 2009-2012 Frank Marien
#   frank@apsu.be
#
#   This file is part of ExtreMon.
#
#   ExtreMon is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ExtreMon is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ExtreMon.  If not, see <http://www.gnu.org/licenses/>.
#

import socket
import urllib.request,time,datetime,sys,os,socket,json
from threading import Thread
from queue import Queue
from x3plugin import X3Out
#------------------------------------------------------------------------


# 
# Tzury Bar Yochay
class NoRedirect(urllib.request.HTTPRedirectHandler):
    def redirect_request(self, req, fp, code, msg, hdrs, newurl):
        pass

# thanks to Carles Barrobes
# http://stackoverflow.com/questions/110498/
# is-there-an-easy-way-to-request-a-url-in-python-and-not-follow
# -redirects/110808
class NoRedirectHandler(urllib.request.HTTPRedirectHandler):
  def http_error_302(self, req, fp, code, msg, headers):
    infourl = urllib.request.addinfourl(fp, headers, req.get_full_url())
    infourl.status = code
    infourl.code = code
    return infourl
  http_error_300=http_error_302
  http_error_301=http_error_302
  http_error_303=http_error_302
  http_error_307=http_error_302

class ResponseTimeProbe(Thread):
  def __init__(self,id,patient,interval,timeout,handler,prefix):
    Thread.__init__(self,name='ReponseTimeProbe [%s]' %(id))
    self.daemon=True
    self.id=id
    self.config=patient
    self.interval=interval
    self.timeout=timeout
    self.handler=handler
    urllib.request.install_opener(
                        urllib.request.build_opener(NoRedirect))

  def run(self):
    self.running=True
    diag=[]
    result=0
    while self.running:
      start=time.time()
      try:
        socket=urllib.request.urlopen(self.config['url'], timeout=self.timeout)
        diag.append('connection ok')
        data=socket.read()
        if len(data)>0:
            diag.append('read %d bytes' % (len(data)))
        else:
            diag.append('no data')
            result=2
        try:
            if data.find(self.config['expect_text'])==-1:
              diag.append('expected text [%s] not found' % (self.config['expect_text']))
              result=2
            else:
              diag.append('expected text ok')
        except KeyError:
            pass
      except urllib.error.HTTPError as response:
        try:
            if response.code!=self.config['expect_code']:
              diag.append('expected response [%d] but got [%d]' % (self.config['expect_code'],response.code))
              result=2
            else:
              diag.append('response code ok');
        except KeyError:
            pass
      except urllib.error.URLError as urlError:
        if len(urlError.reason)>0:
          diag.append('url error %s' % (urlError.reason))
        else:
          diag.append("urlerror")
        result=2
      except:
        diag.append('general error')
        result=2
      
      self.handler.put("%s.%s.httpprobe.responsetime" % (self.handler.prefix, self.id), (time.time()-start)*1000.0)
      self.handler.put("%s.%s.httpprobe.result" % (self.handler.prefix, self.id),result)
      self.handler.put('%s.%s.httpprobe.result.comment' % (self.handler.prefix,self.id), '|'.join(diag))

      del diag[:]                               
      time.sleep(self.interval)

  def stop(self):
    self.running=False
      
class ResponseTimeProbes(X3Out):
  def __init__(self,patients):
    X3Out.__init__(self)
    socket.setdefaulttimeout(int(self.config['timeout']))
    self.patients=patients
    self.interval=float(self.config['interval'])
    self.timeout=float(self.config['timeout'])
    self.prefix=self.config['prefix']
    socket.setdefaulttimeout(int(self.timeout))

    for (id,patient) in self.patients.items():
      try:
        interval=patient['interval']
      except KeyError:
        interval=self.interval

      ResponseTimeProbe(id=id,
                        patient=patient,
                        interval=interval,
                        timeout=self.timeout,
                        prefix=self.prefix,
                        handler=self).start()
    self.log('running')
    while True:
      time.sleep(10)

if __name__=='__main__':
  with open('/etc/x3_httpprobes.conf','r') as confFile:
    patients=json.load(confFile)
  ResponseTimeProbes(patients=patients)
